import crypto from "crypto";
import type { Logger } from "pino";
import { ExtractedElement, ExtractedElementSchema } from "../schemas/extractedElement";
import { NotionService } from "./notionService";

export interface PlanIngestInput {
  projectId: string;
  filename: string;
  buffer: Buffer;
  docHash?: string;
  notes?: string;
  elements?: Array<Partial<ExtractedElement>>;
}

export interface PlanIngestServiceOptions {
  notion: NotionService;
  plansDatabaseId: string;
  elementsDatabaseId: string;
  logger?: Logger;
}

export interface PlanIngestResult {
  planPageId: string;
  elements: ExtractedElement[];
}

export class PlanIngestService {
  private readonly notion: NotionService;
  private readonly plansDatabaseId: string;
  private readonly elementsDatabaseId: string;
  private readonly logger?: Logger;

  constructor(options: PlanIngestServiceOptions) {
    this.notion = options.notion;
    this.plansDatabaseId = options.plansDatabaseId;
    this.elementsDatabaseId = options.elementsDatabaseId;
    this.logger = options.logger;
  }

  async ingest(input: PlanIngestInput): Promise<PlanIngestResult> {
    const docHash = input.docHash ?? this.hashBuffer(input.buffer);

    const planPageId = await this.notion.upsertByUniqueRichText(
      this.plansDatabaseId,
      "Doc Hash",
      docHash,
      () => ({
        Name: {
          title: [{ text: { content: input.filename } }]
        },
        Project: {
          relation: [{ id: input.projectId }]
        },
        Notes: input.notes ? {
          rich_text: [{ text: { content: input.notes.slice(0, 1999) } }]
        } : undefined,
        "Doc Hash": {
          rich_text: [{ text: { content: docHash } }]
        }
      })
    );

    const elements = await this.extractElements(input, docHash);
    const persisted: ExtractedElement[] = [];

    for (const element of elements) {
      const idempotencyKey = `${docHash}:${element.elementKey}`;
      const pageId = await this.notion.upsertByUniqueRichText(
        this.elementsDatabaseId,
        "Idempotency Key",
        idempotencyKey,
        () => buildElementProperties(element, input.projectId, docHash, planPageId)
      );

      persisted.push(ExtractedElementSchema.parse({
        ...element,
        id: pageId,
        projectId: input.projectId,
        docHash,
        notionPageId: pageId,
        createdAt: new Date(),
        updatedAt: new Date()
      }));
    }

    return { planPageId, elements: persisted };
  }

  private async extractElements(input: PlanIngestInput, docHash: string): Promise<ExtractedElement[]> {
    if (input.elements?.length) {
      return input.elements.map((element, index) => {
        const identifier = element.identifier ?? element.elementKey ?? `element-${index + 1}`;

        return ExtractedElementSchema.parse({
          ...element,
          identifier,
          id: element.id ?? `${docHash}-${index}`,
          projectId: input.projectId,
          docHash,
          notionPageId: element.notionPageId ?? `${docHash}-${index}`,
          createdAt: element.createdAt ?? new Date(),
          updatedAt: element.updatedAt ?? new Date(),
          elementKey: element.elementKey ?? identifier
        });
      });
    }

    // Placeholder extraction heuristics; real implementation would parse PDF/DWG.
    const fallbackElement: ExtractedElement = ExtractedElementSchema.parse({
      id: `${docHash}-wall` as string,
      type: "wall",
      identifier: "WALL-AUTO",
      attributesJson: {
        length_ft: 10,
        height_ft: 9
      },
      sheetRef: "A1.1",
      projectId: input.projectId,
      source: "upload",
      confidence: 0.3,
      verified: false,
      elementKey: "auto-wall",
      docHash,
      notes: "Autogenerated placeholder until ML extraction is plugged in",
      notionPageId: `${docHash}-wall` as string,
      createdAt: new Date(),
      updatedAt: new Date()
    });

    this.logger?.warn({ filename: input.filename }, "Plan ingest falling back to heuristic extraction");
    return [fallbackElement];
  }

  private hashBuffer(buffer: Buffer): string {
    return crypto.createHash("sha256").update(buffer).digest("hex");
  }
}

function buildElementProperties(element: ExtractedElement, projectId: string, docHash: string, planPageId: string): Record<string, unknown> {
  return {
    Name: {
      title: [{ text: { content: element.identifier } }]
    },
    Project: {
      relation: [{ id: projectId }]
    },
    Type: {
      select: { name: element.type }
    },
    "Sheet Ref": element.sheetRef ? {
      rich_text: [{ text: { content: element.sheetRef } }]
    } : undefined,
    "Attributes": {
      rich_text: [{ text: { content: JSON.stringify(element.attributesJson) } }]
    },
    "Confidence": {
      number: element.confidence
    },
    Verified: {
      checkbox: element.verified
    },
    "Element Key": {
      rich_text: [{ text: { content: element.elementKey } }]
    },
    "Doc Hash": {
      rich_text: [{ text: { content: docHash } }]
    },
    "Plan": {
      relation: [{ id: planPageId }]
    },
    "Idempotency Key": {
      rich_text: [{ text: { content: `${docHash}:${element.elementKey}` } }]
    }
  };
}
